<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"45UGH4CJ52","apiKey":"c88fb708849de8d55c0523c1f9addc08","indexName":"garannodou","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原文地址：http:&#x2F;&#x2F;lucasfcosta.com&#x2F;2017&#x2F;02&#x2F;17&#x2F;JavaScript-Errors-and-Stack-Traces.html (｡･∀･)ﾉﾞ嗨，大家好！鉴于我几个星期没有写些什么关于JavaScript的东西了，是时候让我们回到正轨了。 这一次，我们将会来探讨一下 errors 和 stack traces，并且熟练的掌握它们。 有些时候人们的确不太注意这些细节，">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻译】深入了解JavaScript错误和堆栈追踪">
<meta property="og:url" content="http://yoursite.com/2017/03/06/JavaScript%20Errors%20and%20Stack%20Traces%20in%20Depth/index.html">
<meta property="og:site_name" content="Veda">
<meta property="og:description" content="原文地址：http:&#x2F;&#x2F;lucasfcosta.com&#x2F;2017&#x2F;02&#x2F;17&#x2F;JavaScript-Errors-and-Stack-Traces.html (｡･∀･)ﾉﾞ嗨，大家好！鉴于我几个星期没有写些什么关于JavaScript的东西了，是时候让我们回到正轨了。 这一次，我们将会来探讨一下 errors 和 stack traces，并且熟练的掌握它们。 有些时候人们的确不太注意这些细节，">
<meta property="og:locale">
<meta property="article:published_time" content="2017-03-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-01T20:30:17.657Z">
<meta property="article:author" content="张煜航">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="translation">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2017/03/06/JavaScript%20Errors%20and%20Stack%20Traces%20in%20Depth/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>【翻译】深入了解JavaScript错误和堆栈追踪 | Veda</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Veda</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">A collection of my tranlation and a few of mind。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/06/JavaScript%20Errors%20and%20Stack%20Traces%20in%20Depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张煜航">
      <meta itemprop="description" content="Do you best, and God will do the lest.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veda">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【翻译】深入了解JavaScript错误和堆栈追踪
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-06T00:00:00+08:00">2017-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-02 04:30:17" itemprop="dateModified" datetime="2023-02-02T04:30:17+08:00">2023-02-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>原文地址：<a target="_blank" rel="noopener" href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html">http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html</a></p>
<p>(｡･∀･)ﾉﾞ嗨，大家好！鉴于我几个星期没有写些什么关于JavaScript的东西了，是时候让我们回到正轨了。</p>
<p>这一次，我们将会来探讨一下 errors 和 stack traces，并且熟练的掌握它们。</p>
<p>有些时候人们的确不太注意这些细节，但是这些细节知识在当你写一个库，并且需要测试和调错时会非常有用。举个例子，这周在 Chai 时，我们有一个很棒的pull-request，关于如何提升我们在堆栈追踪的处理能力上，从而能够使我们的用户能够在 assert 测试失败时，能够获得更多的信息。</p>
<p>熟练的操控堆栈追踪能偶让你清理掉一些不必要的干扰信息，从而能够关注于真正的问题上。此外，当你理解什么是错误及其属性，你会感到更有信心利用它。</p>
<p><strong>这篇博文在开头可能看起来太浅显了，但是当我们开始操作堆栈追踪时，它变得相当复杂，因此在我们进入那个章节之前，请确保您对以前的内容有了很好的理解。</strong></p>
<h3 id="调用堆栈是如何工作的"><a href="#调用堆栈是如何工作的" class="headerlink" title="调用堆栈是如何工作的"></a>调用堆栈是如何工作的</h3><p>在我们讨论errors之前，我们必须理解调用堆栈是如何工作的。（的确）这很单调，不过在深入之前理解这些是很有必要的。如果你已经知道了这些，请随意跳过这节。</p>
<p><strong>当一个方法被调用时，它会被push到栈顶。在它执行完成后，它会从栈顶被移除。</strong></p>
<p>这种数据结构有趣的地方在于 <strong>最后进来的元素会最先出去</strong>。同样这被称作 LIFO (后入先出) 原则。</p>
<p>给你看另一个例子，假设你有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，当运行方法a时，它被添加到我们栈的顶部。然后，当方法 b 在方法 a 内被调用时，它也被添加到了栈顶。同样的事也发生在方法 c 在方法 b 内被调用时。</p>
<p>当运行方法 c 时，我们的堆栈追踪内顺序包含 a, b, c 三个方法。</p>
<p>一旦方法 c 结束运行，它从栈顶被移除，控制权重新交回给方法 b 。当方法 b 完成时，它也从栈顶被移除，现在控制权被交回到了方法 a 手中。最终，当方法 a 结束运行后，它同样也从栈顶被移除。</p>
<p>为了更好的演示这些行为，我们将会使用<code>console.trace()</code>方法。它能够在控制台种将当前的堆栈信息打印出来。同样，你应该从上到下来阅读这些信息。仔细想想下面每一行代码被调用时都发生了什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">trace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>当代码在 node REPL 运行时，我们得到下面一些信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Trace</span></span><br><span class="line">    at c (<span class="attr">repl</span>:<span class="number">3</span>:<span class="number">9</span>)</span><br><span class="line">    at b (<span class="attr">repl</span>:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at a (<span class="attr">repl</span>:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at <span class="attr">repl</span>:<span class="number">1</span>:<span class="number">1</span> <span class="comment">// &lt;-- 这个指针下面的东西都是Nodejs的内部实现，无视就好</span></span><br><span class="line">    at realRunInThisContextScript (vm.<span class="property">js</span>:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.<span class="property">js</span>:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at <span class="title class_">ContextifyScript</span>.<span class="property">Script</span>.<span class="property">runInThisContext</span> (vm.<span class="property">js</span>:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at <span class="title class_">REPLServer</span>.<span class="property">defaultEval</span> (repl.<span class="property">js</span>:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.<span class="property">js</span>:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at <span class="title class_">REPLServer</span>.<span class="property">runBound</span> [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.<span class="property">js</span>:<span class="number">293</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>简单的讲：你调用了一个东西，它被压入栈顶。当它完成了它就被弹出。就是这么简单。</p>
<h3 id="错误对象和错误处理"><a href="#错误对象和错误处理" class="headerlink" title="错误对象和错误处理"></a>错误对象和错误处理</h3><p>当错误发生时，通常一个 <code>Error</code> 对象被抛出。<code>Error</code> 对象同样也被当作原型来使用，来拓展或创建自己的错误。</p>
<p><code>Error.prototype</code> 对象通常包含下面属性：</p>
<ul>
<li><code>constructor</code> - 构造函数负责这个实例的原型。</li>
<li><code>message</code> - 一条错误信息。</li>
<li><code>name</code> - 错误的名称</li>
</ul>
<p>上述这些是标准的属性，有些时候不同的环境会有它们自己特定参数。在一些环境下，比如 Node, Firefox, Chrome, Edge, IE 10+, Opera 和 Safari 6+，我们甚至会有 <code>stack</code> 参数，它包含了一个错误的堆栈追踪信息。</p>
<p><strong>一个错误的堆栈追踪信息包含所有到它自身的结构函数为止的栈帧信息</strong>。</p>
<p>如果你希望了解更多的<code>Error</code>对象的参数，我非常推荐你去看看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/prototype">MDN上的这篇文章</a>.</p>
<p>为了抛出一个错误你必须使用<code>throw</code> 关键词。为了<code>catch</code> 一个被抛出的错误，你必须用<code>try catch</code>将那些可能会抛出错误的代码包裹起来。Catch 同样可以接收一个被抛出的错误作为参数。</p>
<p>如同在 java 种发生的一样， JavaScript 同样允许你在<code>try/catch</code>之后添加一个 <code>finally</code> 区块而不需要去关系 <code>try</code>区块内是否发生了错误。使用 <code>finally</code> 来做好一些善后工作，而不用关心你的操作是否正常工作。</p>
<p>到目前为止的所有东西对于大多数人而言都很基础，所有让我们来看一些不太注意的细节。（译者： indeed 😭）</p>
<p>你可以使用 <code>try</code>区块而不在后面带上 <code>catch</code>区块，但是这时必须带上 <code>finally</code>。这意味着你可以使用三种不同的try表达式结构：</p>
<ul>
<li><code>try...catch</code></li>
<li><code>try...finally</code></li>
<li><code>try...catch...finally</code></li>
</ul>
<p>Try表达式能够签到在其他的 <code>try</code> 表达式内，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Nested error.&#x27;</span>); <span class="comment">// 这里抛出的错误会被他自身的catch子句所捕获</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Nested catch&#x27;</span>); <span class="comment">// This runs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This will not run.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你同样可以将 <code>try</code>嵌入 <code>catch</code> 和 <code>finally</code> 区块内：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;First error&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;First catch running&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Second error&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Second catch running.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(&#x27;The try block is running...&#x27;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new Error(&#x27;Error inside finally.&#x27;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(&#x27;Caught an error inside the finally block.&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样重要的是，<strong>你要知道throw 同样可以抛出非 <code>Error</code> 对象</strong>。尽管这看起来很cool，但是实际上真的不好，特别是那些需要在开发时使用其他库的开发者们，他们不得不去处理别人的代码，因为这之前并没有标准，你永远不会知道用户会给你什么东西。你不能信任他们而单纯的只是抛出一个<code>Error</code> 对象，因为他们可能选择不这么做，取而代之，而是抛出一个字符串或者数字。这使得你在处理堆栈追踪和其他一些有价值的元数据时变得困难。</p>
<p>假设你有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runWithoutThrowing</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">func</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;There was an error, but I will not throw it.&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The error\&#x27;s message was: &#x27;</span> + e.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcThatThrowsError</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;I am a TypeError.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runWithoutThrowing</span>(funcThatThrowsError);</span><br></pre></td></tr></table></figure>

<p>当使用者传递一个含有错误抛出的方法到你的 <code>runWithoutThrowing</code>函数时，一切都正常工作。但是如果他们抛了一个 <code>String</code> 给你时，那你就有麻烦了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runWithoutThrowing</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">func</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;There was an error, but I will not throw it.&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The error\&#x27;s message was: &#x27;</span> + e.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcThatThrowsString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;I am a String.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runWithoutThrowing</span>(funcThatThrowsString);</span><br></pre></td></tr></table></figure>

<p>现在你的第二行 <code>console.log</code> 将告诉你 error 的 message 是 <code>undefined</code> 。这看起来在当前似乎不是很重要，不过如果你需要确认<code>Error</code> 对象内存在的一个特定的属性后者需要从用一种方法上处理 <code>Error </code> 特定属性时（比如  <a target="_blank" rel="noopener" href="https://github.com/chaijs/chai/blob/a7e1200db4c144263599e5dd7a3f7d1893467160/lib/chai/core/assertions.js#L1506">Chai’s<code>throws</code> 断言文档</a>），你需要做更多的工作。</p>
<p>同样的，当抛出值不是 <code>Error</code>  对象时，你不需要去访问其他重要的数据，比如它的<code>stack</code>，一个在一些环境中 <code>Error</code> 对象所包含的字段。</p>
<p>错误同样可以被当作其他（一般）的对象来使用，你并不一定要把他们抛出。这就是为什么它们经常被当初回调函数的第一个参数的原因。比如，在 <code>fs.readdir</code> 方法种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;/example/i-do-not-exist&#x27;</span>, <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">err, dirs</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">    <span class="comment">// `readdir` 将会抛出一个错误，因为这个文件根本不存在    </span></span><br><span class="line">    <span class="comment">// 现在我们能够使用回调函数中的错误对象了</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error Message:&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;See? We can use Errors without using try statements.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dirs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最后但并非不重要， <code>Error</code> 对象在 promise  reject 时被使用。这使得控制promise的rejections变得容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;The promise was rejected.&#x27;</span>));</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an error.&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The promise was rejected with an error.&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error Message:&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="操作堆栈追踪"><a href="#操作堆栈追踪" class="headerlink" title="操作堆栈追踪"></a>操作堆栈追踪</h3><p>现在就是你所期待的部分了：如何去操作堆栈追踪信息。</p>
<p>这个章节只针对一些支持 <code>Error.captureStackTrace</code> 的特殊环境，比如 NodeJS。</p>
<p>这个 <code>Error.captureStackTrace</code> 方法将一个 <code>object</code> 作为它的一个参数，一个可选的 <code>function</code> 作为它的第二个参数。这个 captureStackTrace 做的呢就是捕获当前的堆栈信息（废话）并且在一个大的对象中创建一个 <code>stack</code> 参数来保存它。如果提供了第二个参数，这个被传递的方法将会被认为是调用堆栈的重点。因此堆栈跟踪将仅显示在调用此函数之前发生的调用。</p>
<p>让我们给一些例子来让这一切变得更清晰。首先，我们将会捕获当前的堆栈信息，并且将它保存在一个普通的对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 这里将会讲当前的堆栈信息储存到 myObj 中</span></span><br><span class="line">  <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(myObj);</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们会调用这些方法</span></span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在让我们看看什么堆栈信息被存入了 myObj.stack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会在控制台中打印出如下信息：</span></span><br><span class="line"><span class="comment">//    at b (repl:3:7) &lt;-- 因为它在B内被调用，所以B是堆栈中的最后一个条目</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1)</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- 下面是 node 的内部实现</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br></pre></td></tr></table></figure>

<p>正如你在上述例子中看到的，我们首先调用了 <code>a</code> （被压入了栈内）然后在 <code>a</code> 内调用了 <code>b</code> （被 push 在 <code>a</code> 上面）。然后，在 <code>b</code> 内，我们捕获到了当前的堆栈信息，并且存入了 <code>myObj</code>。 这就是为什么我们在控制台中只获得了 <code>a</code> 和 <code>b</code>。 </p>
<p>现在，让我们传递一个方法作为第二个参数给<code>Error.captureStackTrace</code> 方法，来看会发生什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里我们将会储存当前的堆栈信息到 myObj 中</span></span><br><span class="line">  <span class="comment">// 这一次我么将会隐藏 `b` 之后以及它自身的栈帧 </span></span><br><span class="line">  <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(myObj, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">d</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">c</span>();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们会调用这些方法</span></span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在让我们看看什么堆栈信息被存入了 myObj.stack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会在控制台中打印出如下信息：</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1) &lt;-- 如你所见在这里我们只能获得 `b` 之前的被调用的栈帧</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- 下面是 node 的内部实现</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br><span class="line"><span class="comment">//    at emitOne (events.js:101:20)</span></span><br></pre></td></tr></table></figure>

<p>当我们传递 <code>b</code> 给<code>Error.captureStackTrace</code> 函数时，它隐藏了 <code>b</code> 本身以及在它之上的所有栈帧。这就是为什么我们在堆栈追踪中只看到了<code>a</code>。</p>
<p>现在你或许会问你自己： “为什么这东西有用？”。这个东西在当你试图对非你的用户隐藏内部实现细节时非常有用。在 Chai 内，举个例子， 们使用它来避免向我们的用户显示与我们实现检查和断言自身的方式无关的细节。</p>
<h3 id="真实环境中的堆栈追踪操作"><a href="#真实环境中的堆栈追踪操作" class="headerlink" title="真实环境中的堆栈追踪操作"></a>真实环境中的堆栈追踪操作</h3><p>正如我在上一个小节提到的，Chai 使用堆栈操作技术来使得堆栈追踪与我们的用户（的操作）更加关联。下面是我们如何做的。</p>
<p>首先，让我们看一看当断言失败时， <code>AssertionError</code> 构造函数会抛出什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ssfi` 代表 “start stack function”. 它指向堆栈追踪中删除不相关帧的起点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AssertionError</span> (message, _props, ssf) &#123;</span><br><span class="line">  <span class="keyword">var</span> extend = <span class="title function_">exclude</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;stack&#x27;</span>, <span class="string">&#x27;constructor&#x27;</span>, <span class="string">&#x27;toJSON&#x27;</span>)</span><br><span class="line">    , props = <span class="title function_">extend</span>(_props || &#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;Unspecified AssertionError&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">showDiff</span> = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从参数中拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[key] = props[key];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里就是与我们相关的部分：</span></span><br><span class="line">  <span class="comment">// 如果一个start stack function 被提供了，我们捕获了当前堆栈的追踪信息，并且将其传递给了 `captureStackTrace` 方法，那样我们移除在这个之后的栈帧了。</span></span><br><span class="line">  ssf = ssf || <span class="variable language_">arguments</span>.<span class="property">callee</span>;</span><br><span class="line">  <span class="keyword">if</span> (ssf &amp;&amp; <span class="title class_">Error</span>.<span class="property">captureStackTrace</span>) &#123;</span><br><span class="line">    <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(<span class="variable language_">this</span>, ssf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有提供 start stack function 我们就用原来的 stack 属性。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stack</span> = e.<span class="property">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，在上面的代码中我们使用 <code>Error.captureStackTrace</code> 来捕获堆栈信息，并且将其储存在我们所生成的 <code>AssertionError</code> 实例中，（当它存在时）我们传递了一个 start stack function 给它来将不相干的栈帧从栈列内移除。这些仅仅展示了Chai的内部实现细节并且在最后污染了栈列。</p>
<p>现在让我们看看现在由 <a target="_blank" rel="noopener" href="https://github.com/meeber">@meeber</a>在 <a target="_blank" rel="noopener" href="https://github.com/chaijs/chai/pull/922">这个碉堡的PR内</a>的代码是怎么写的.</p>
<p>在我们看下面的代码之前，我必须告诉你 <code>addChainableMethod</code> 方法做了什么。它将传递给它的可链接方法添加到断言，并且还使用包含断言的方法标记断言本身。它以 <code>ssfi</code> 作为名称保存（代表了起始栈方法指示器）。这基本上意味着当前断言将是堆栈中的最后一帧，因此我们不会在堆栈中显示Chai中的任何进一步的内部方法。我避免添加整个代码，因为它有很多东西，而且有点棘手，但如果你想读它，<a target="_blank" rel="noopener" href="https://github.com/meeber/chai/blob/42ff3c012b8a5978e7381b17d712521299ced341/lib/chai/utils/addChainableMethod.js">这里是它的链接</a>.。</p>
<p>在下面的代码中，我们有一个 <code>lengthOf</code> 断言的逻辑，它检查对象是否具有一个明确的 <code>长度</code>。我们希望我们的用户像这么用它：<code>expect([&#39;foo&#39;, &#39;bar&#39;]).to.have.lengthOf(2)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assertLength</span> (n, msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg) <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;message&#x27;</span>, msg);</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">        , ssfi = <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;ssfi&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这一行</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Assertion</span>(obj, msg, ssfi, <span class="literal">true</span>).<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">property</span>(<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> len = obj.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一行也同样相关</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">assert</span>(</span><br><span class="line">            len == n</span><br><span class="line">        , <span class="string">&#x27;expected #&#123;this&#125; to have a length of #&#123;exp&#125; but got #&#123;act&#125;&#x27;</span></span><br><span class="line">        , <span class="string">&#x27;expected #&#123;this&#125; to not have a length of #&#123;act&#125;&#x27;</span></span><br><span class="line">        , n</span><br><span class="line">        , len</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Assertion</span>.<span class="title function_">addChainableMethod</span>(<span class="string">&#x27;lengthOf&#x27;</span>, assertLength, assertLengthChain);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我突出强调了与我们现在相关的代码段。我们先来看看 <code>this.assert</code> 的调用。</p>
<p>下面是 <code>this.assert</code> 方法的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Assertion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">assert</span> = <span class="keyword">function</span> (<span class="params">expr, msg, negateMsg, expected, _actual, showDiff</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ok = util.<span class="title function_">test</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> !== showDiff) showDiff = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">undefined</span> === expected &amp;&amp; <span class="literal">undefined</span> === _actual) showDiff = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> !== config.<span class="property">showDiff</span>) showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        msg = util.<span class="title function_">getMessage</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> actual = util.<span class="title function_">getActual</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是我们所要关注的行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(msg, &#123;</span><br><span class="line">                <span class="attr">actual</span>: actual</span><br><span class="line">            , <span class="attr">expected</span>: expected</span><br><span class="line">            , <span class="attr">showDiff</span>: showDiff</span><br><span class="line">        &#125;, (config.<span class="property">includeStack</span>) ? <span class="variable language_">this</span>.<span class="property">assert</span> : <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;ssfi&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基本上，<code>assert</code>方法负责检查是否通过了布尔表达式的断言。如果没有，我们必须实例化一个<code>AssertionError</code>。请注意，当实例化这个新的<code>AssertionError</code>时，我们也向其传递一个堆栈跟踪功能指示符（<code>ssfi</code>）。如果配置标志<code>includeStack</code>被打开，我们通过将<code>this.assert</code>本身传递给它来显示整个堆栈跟踪，这真的是堆栈中的最后一帧。但是，如果<code>includeStack</code>配置标志被启用，我们必须从堆栈跟踪中隐藏更多的内部实现细节，所以我们使用什么存储到<code>ssfi</code>标志。</p>
<p>现在，我们来谈谈另一个相关的行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Assertion</span>(obj, msg, ssfi, <span class="literal">true</span>).<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">property</span>(<span class="string">&#x27;length&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>正如你可以看到的，我们在创建我们的嵌套断言时传递了我们从<code>ssfi</code>标志获得的内容。这意味着当创建新的断言时，它将使用此函数作为从堆栈跟踪中删除无用框架的起点。顺便说一下，这是<code>Assertion</code>构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Assertion</span> (obj, msg, ssfi, lockSsfi) &#123;</span><br><span class="line">    <span class="comment">// This is the line that matters to us</span></span><br><span class="line">    <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;ssfi&#x27;</span>, ssfi || <span class="title class_">Assertion</span>);</span><br><span class="line">    <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;lockSsfi&#x27;</span>, lockSsfi);</span><br><span class="line">    <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;object&#x27;</span>, obj);</span><br><span class="line">    <span class="title function_">flag</span>(<span class="variable language_">this</span>, <span class="string">&#x27;message&#x27;</span>, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> util.<span class="title function_">proxify</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以记住从我对<code>addChainableMethod</code>的说法，它设置<code>ssfi</code>标志与自己的包装方法，这意味着这是堆栈跟踪中最低的内部帧，所以我们可以删除所有上面的帧。</p>
<p>通过将<code>ssfi</code>传递给嵌套断言，它只检查我们的对象是否具有属性长度，我们避免重置我们将用作起点指示符的帧，然后在堆栈中使得之前的<code>addChainableMethod</code>保持可见。</p>
<p>这可能看起来有点复杂，所以让我们回顾一下Chai发生的事情，我们想从堆栈中删除无用的帧：</p>
<ol>
<li>当我们运行断言时，我们设置自己的方法作为删除堆栈中的下一个帧的参考</li>
<li>断言运行，如果它失败，我们删除我们存储的引用后的所有内部帧</li>
<li>如果我们有嵌套断言，我们仍然必须使用当前的断言包装方法作为删除堆栈中的下一个帧的参考点，所以我们将当前的<code>ssfi</code>（启动堆栈函数指示符）传递给我们正在创建的断言，以便它可以保留它</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
              <a href="/tags/translation/" rel="tag"># translation</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/02/13/React%20Fiber%20Architecture/" rel="prev" title="【翻译】React Fiber架构">
      <i class="fa fa-chevron-left"></i> 【翻译】React Fiber架构
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/03/22/Nothing/" rel="next" title="一些需要思考的事情">
      一些需要思考的事情 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">1.</span> <span class="nav-text">调用堆栈是如何工作的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">错误对象和错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%A0%86%E6%A0%88%E8%BF%BD%E8%B8%AA"><span class="nav-number">3.</span> <span class="nav-text">操作堆栈追踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%9F%E5%AE%9E%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E8%BF%BD%E8%B8%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">真实环境中的堆栈追踪操作</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张煜航</p>
  <div class="site-description" itemprop="description">Do you best, and God will do the lest.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张煜航</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
